name: Build geoip
on:
  workflow_dispatch:
  schedule:
    # Запуск каждый 3-й день в 03:00 UTC
    - cron: '0 3 */3 * *'
  push:
    branches:
      - main
    paths-ignore:
      - "README.md"
      - ".gitignore"
      - "LICENSE"

permissions:
  contents: write

jobs:
  build:
    name: Build
    runs-on: ubuntu-latest
    steps:
      - name: Checkout codebase
        uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - name: Checkout v2fly/geoip
        uses: actions/checkout@v6
        with:
          repository: v2fly/geoip
          path: geoip
          fetch-depth: 1

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version-file: geoip/go.mod
          cache: true
          cache-dependency-path: geoip/go.sum

      - name: Download custom config.json
        run: |
          curl -fsSL -o config.json https://raw.githubusercontent.com/hydraponique/roscomvpn-geoip/master/config.json

      - name: Download custom ipset_ops.py
        run: |
          curl -fsSL -o ipset_ops.py https://raw.githubusercontent.com/hydraponique/roscomvpn-geoip/master/ipset_ops.py

      - name: Overlay custom files over geoip
        run: |
          set -euo pipefail
          cp -f config.json geoip/ 2>/dev/null || true
          cp -f ipset_ops.py geoip/ 2>/dev/null || true

      - name: Set tag
        if: github.ref_name == 'main'
        run: |
          set -euo pipefail
          DAILY_TAG=$(date +%Y%m%d%H%M)
          echo "DAILY_TAG=$DAILY_TAG" >> "$GITHUB_ENV"

      - name: Create Tag
        if: github.ref_name == 'main'
        uses: actions/github-script@v8
        with:
          script: |
            const { DAILY_TAG } = process.env
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${DAILY_TAG}`,
              sha: context.sha
            })

      - name: Download inputs (IP lists + Geobases)
        working-directory: geoip
        run: |
          set -euo pipefail
          CURL="curl -fsSL --retry 3 --retry-delay 2 --retry-connrefused"

          $CURL -o refilterbeta.txt https://raw.githubusercontent.com/1andrevich/Re-filter-lists/refs/heads/beta/ipsum.lst
          $CURL -o antifilterdownloadcommunity.txt https://community.antifilter.download/list/community.lst
          $CURL -o refilter.txt https://raw.githubusercontent.com/1andrevich/Re-filter-lists/refs/heads/main/ipsum.lst
          $CURL -o refiltercommunity.txt https://raw.githubusercontent.com/1andrevich/Re-filter-lists/refs/heads/main/community_ips.lst
          $CURL -o antifilternetwork.txt https://antifilter.network/download/ip.lst
          $CURL -o antifilternetworkcommunity.txt https://antifilter.network/downloads/custom.lst
          $CURL -o cdn.lst https://raw.githubusercontent.com/mansourjabin/cdn-ip-database/refs/heads/main/data/cdn.lst
          $CURL -o merged.sum https://raw.githubusercontent.com/PentiumB/CDN-RuleSet/refs/heads/main/release/merged.sum

          $CURL -o geolite_ru.lst https://raw.githubusercontent.com/hydraponique/countrydb/refs/heads/main/output/geolite2-geo-whois-asn-country-ipv4/ru.lst
          $CURL -o geolite_by.lst https://raw.githubusercontent.com/hydraponique/countrydb/refs/heads/main/output/geolite2-geo-whois-asn-country-ipv4/by.lst
          $CURL -o ipinfo_ru.lst https://raw.githubusercontent.com/Davoyan/ipinfo/refs/heads/main/geo/geoip/ru.lst
          $CURL -o ipinfo_by.lst https://raw.githubusercontent.com/Davoyan/ipinfo/refs/heads/main/geo/geoip/by.lst
          $CURL -o dbip_ru.lst https://raw.githubusercontent.com/hydraponique/countrydb/refs/heads/main/output/dbip-country-ipv4/ru.lst
          $CURL -o dbip_by.lst https://raw.githubusercontent.com/hydraponique/countrydb/refs/heads/main/output/dbip-country-ipv4/by.lst

          rm -rf geolite2
          mkdir -p geolite2
          $CURL "https://dl.netsyms.net/dbs/geolite2/GeoLite2-Country-CSV.zip" -o geolite2/GeoLite2-Country-CSV.zip
          unzip -o geolite2/GeoLite2-Country-CSV.zip -d geolite2
          mv geolite2/GeoLite2-Country-CSV_*/* geolite2/
          rmdir geolite2/GeoLite2-Country-CSV_* || true

      - name: Build geoip tool
        working-directory: geoip
        run: |
          set -euo pipefail
          go mod download
          go build -o geoip

      - name: Generate geoip artifacts (RU/BY preparation)
        working-directory: geoip
        run: |
          set -euo pipefail
          rm -rf tmp output
          mkdir -p tmp/text output/dat output/text

          rm -f ./tmp/text/prepare.txt
          : > ./tmp/text/prepare.txt
          for f in ./geolite_ru.lst ./geolite_by.lst ./ipinfo_ru.lst ./ipinfo_by.lst ./dbip_ru.lst ./dbip_by.lst; do
            if [ -f "$f" ]; then
              cat "$f" >> ./tmp/text/prepare.txt
              printf '\n' >> ./tmp/text/prepare.txt
            fi
          done

      - name: Apply custom lists and filtering
        working-directory: geoip
        run: |
          set -euo pipefail
          if [ -f ./CUSTOM-LIST-ADD.txt ]; then
            cat ./CUSTOM-LIST-ADD.txt >> ./tmp/text/prepare.txt
            printf '\n' >> ./tmp/text/prepare.txt
          fi

          python3 ipset_ops.py --mode diff \
            --A ./tmp/text/prepare.txt \
            --B ./refilterbeta.txt,./refilter.txt,./antifilternetwork.txt,./antifilterdownloadcommunity.txt,./refiltercommunity.txt,./antifilternetworkcommunity.txt,./cdn.lst,./merged.sum,./CUSTOM-LIST-DEL.txt \
            --out ./tmp/text/final.txt

      - name: Generate geoip artifacts (Final build with modified config)
        working-directory: geoip
        run: |
          set -euo pipefail
          
          python3 -c "
          import json
          with open('config.json', 'r', encoding='utf-8') as f:
              config_data = json.load(f)
          
          for input_entry in config_data.get('input', []):
              if input_entry.get('type') == 'text' and input_entry.get('action') == 'add':
                  args = input_entry.get('args', {})
                  if args.get('name') == 'direct':
                      args['name'] = 'ru'
                      print('Changed input name from direct to ru')
          
          for output_entry in config_data.get('output', []):
              if output_entry.get('type') == 'v2rayGeoIPDat' and output_entry.get('action') == 'output':
                  output_entry['args']['wantedList'] = ['ru', 'private']
                  print('Added wantedList [\"ru\", \"private\"] to v2rayGeoIPDat output')
          
          with open('config.json', 'w', encoding='utf-8') as f:
              json.dump(config_data, f, indent=2, ensure_ascii=False)
          "
          
          ./geoip -c config.json
          ls -l output/dat/*.dat

      # ========== ПОДГОТОВКА ТЕКСТОВЫХ ФАЙЛОВ ==========

      - name: Prepare workdir (copy ALL text files + clean with awk)
        run: |
          set -euo pipefail
          work=/tmp/geoip-text
          rm -rf "$work"
          mkdir -p "$work"
          shopt -s nullglob
          cp -f geoip/output/text/*.txt "$work"/
          shopt -u nullglob
          for f in "$work"/*.txt; do
            tmp="$(mktemp)"
            awk '
              function trim(s){ sub(/^[ \t]+/, "", s); sub(/[ \t]+$/, "", s); return s }
              {
                gsub(/\r/, "")
                s=$0
                sub(/[ \t]*#.*/, "", s)
                sub(/[ \t]*\/\/.*/, "", s)
                sub(/[ \t]*@.*/, "", s)
                s=trim(s)
                if (s=="") next
                print s
              }
            ' "$f" > "$tmp"
            mv "$tmp" "$f"
          done

      # ========== ГЕНЕРАЦИЯ MMDB (MAXMIND) ДЛЯ CLASH META ==========

      - name: Build GeoIP MMDB (.mmdb) for Clash Meta
        run: |
          set -euo pipefail
          
          src=/tmp/geoip-text
          out=/tmp/geoip-mmdb
          rm -rf "$out"
          mkdir -p "$out"
          
          # Изолированная директория для Go-модуля
          MMDB_DIR="/tmp/mmdb-gen"
          rm -rf "$MMDB_DIR"
          mkdir -p "$MMDB_DIR"
          cd "$MMDB_DIR"
          
          # Инициализация модуля
          go mod init mmdb-gen
          
          # Go-скрипт для генерации MMDB
          cat > main.go << 'GOEOF'
package main

import (
	"bufio"
	"fmt"
	"net"
	"os"
	"strings"

	"github.com/maxmind/mmdbwriter"
	"github.com/maxmind/mmdbwriter/mmdbtype"
)

func main() {
	if len(os.Args) < 4 {
		fmt.Fprintf(os.Stderr, "Usage: %s <input.txt> <output.mmdb> <country_code>\n", os.Args[0])
		os.Exit(1)
	}

	inputFile := os.Args[1]
	outputFile := os.Args[2]
	countryCode := strings.ToUpper(os.Args[3])

	writer, err := mmdbwriter.New(mmdbwriter.Options{
		DatabaseType:            "GeoIP2-Country",
		RecordSize:              28,
		IncludeReservedNetworks: true,
	})
	if err != nil {
		fmt.Fprintf(os.Stderr, "mmdbwriter.New: %v\n", err)
		os.Exit(1)
	}

	file, err := os.Open(inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "os.Open: %v\n", err)
		os.Exit(1)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	count := 0
	for scanner.Scan() {
		line := strings.TrimSpace(scanner.Text())
		if line == "" || strings.HasPrefix(line, "#") || strings.HasPrefix(line, "//") {
			continue
		}
		_, cidr, err := net.ParseCIDR(line)
		if err != nil {
			continue
		}
		data := mmdbtype.Map{
			"country": mmdbtype.Map{
				"iso_code": mmdbtype.String(countryCode),
			},
		}
		if err := writer.Insert(cidr, data); err != nil {
			continue
		}
		count++
	}

	if err := scanner.Err(); err != nil {
		fmt.Fprintf(os.Stderr, "scanner.Err: %v\n", err)
		os.Exit(1)
	}

	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "os.Create: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	if _, err := writer.WriteTo(f); err != nil {
		fmt.Fprintf(os.Stderr, "writer.WriteTo: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s with %d entries\n", outputFile, count)
}
GOEOF

          # Зависимости и сборка
          go get github.com/maxmind/mmdbwriter@latest
          go build -o mmdb-gen .
          
          # Конвертация ru.txt → geoip.mmdb
          if [ -f "$src/ru.txt" ] && [ -s "$src/ru.txt" ]; then
            "$MMDB_DIR/mmdb-gen" "$src/ru.txt" "$out/geoip.mmdb" "RU"
          else
            # Пустая база, если список пустой
            touch /tmp/empty.txt
            "$MMDB_DIR/mmdb-gen" /tmp/empty.txt "$out/geoip.mmdb" "RU"
          fi
          
          ls -l "$out"/*.mmdb
          file "$out/geoip.mmdb"

      # ========== ПУБЛИКАЦИЯ ==========

      - name: Prepare release directory (main)
        if: github.ref_name == 'main'
        run: |
          set -euo pipefail
          rm -rf publish /tmp/publish
          mkdir -p publish

          # Копируем .dat файлы
          cp geoip/output/dat/*.dat publish/

          # Копируем .mmdb файл (для geox-url.geoip)
          cp -f /tmp/geoip-mmdb/geoip.mmdb publish/

          # Контрольная сумма
          sha256sum publish/geoip.dat > publish/geoip.dat.sha256

          # Копируем для архива релиза
          cp -r publish /tmp/publish

      - name: Git push assets to "release" branch
        if: github.ref_name == 'main'
        run: |
          cd publish || exit 1
          git init
          git config --local user.name "github-actions[bot]"
          git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git checkout -b release
          git add -A
          git commit -m "${{ env.DAILY_TAG }}"
          git remote add origin "https://${{ github.actor }}:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}"
          git push -f -u origin release

      - name: Purge jsdelivr CDN
        if: github.ref_name == 'main'
        run: |
          set -euo pipefail
          cd publish || exit 1
          find . -type f -print0 | while IFS= read -r -d '' f; do
            rel="${f#./}"
            curl -i "https://purge.jsdelivr.net/gh/${{ github.repository }}@release/${rel}"
          done

      - name: Publish GitHub Release
        if: github.ref_name == 'main'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ env.DAILY_TAG }}
          name: ${{ env.DAILY_TAG }}
          prerelease: false
          draft: false
          files: |
            publish/*.dat
            publish/*.dat.sha256
            publish/*.mmdb

      # ========== TEST BRANCH ==========

      - name: Prepare release directory (test)
        if: github.ref_name != 'main'
        run: |
          set -euo pipefail
          rm -rf publish /tmp/publish
          mkdir -p publish

          cp geoip/output/dat/*.dat publish/
          cp -f /tmp/geoip-mmdb/geoip.mmdb publish/
          sha256sum publish/geoip.dat > publish/geoip.dat.sha256
          cp -r publish /tmp/publish

      - name: Push artifacts to test-release branch
        if: github.ref_name != 'main'
        env:
          BRANCH: test-release
        run: |
          set -euo pipefail
          stash=/tmp/test-release-artifacts
          rm -rf "$stash"
          mkdir -p "$stash"
          cp -a publish/. "$stash"/

          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git reset --hard
          git clean -fdx

          if git ls-remote --exit-code --heads origin "$BRANCH" >/dev/null; then
            git fetch --depth=1 origin "$BRANCH"
            git switch -C "$BRANCH" "origin/$BRANCH"
          else
            git switch --orphan "$BRANCH"
          fi

          find . -mindepth 1 -maxdepth 1 ! -name '.git' -exec rm -rf {} +
          cp -a "$stash"/. .

          git add -A
          git commit -m "Publish $(date -u +%Y%m%d%H%M)" --allow-empty
          git push origin HEAD:"$BRANCH"